import Foundation

extension State {
    
    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    public func listItems<Item: ListItem, Section: ListSection>(
        valueToSections: @escaping (Value) -> [SectionWithItems<Item, Section>]?,
        loadingSection: (() -> SectionWithItems<Item, Section>)? = nil,
        errorSection: ((E) -> SectionWithItems<Item, Section>)? = nil,
        noResultsSection: (() -> SectionWithItems<Item, Section>)? = nil) -> ListSections<Item, Section> {
        
        func boxedValueToSections(_ box: EquatableBox<Value>?) -> [SectionWithItems<Item, Section>]? {
            return (box?.value).flatMap({ valueToSections($0) })
        }
        
        func noResultsOrErrorSection() -> ListSections<Item, Section> {
            if let error = self.error {
                if let errorSection = errorSection {
                    return ListSections.readyToDisplay([errorSection(error)])
                } else if let noResultsSection = noResultsSection {
                    return ListSections.readyToDisplay([noResultsSection()])
                } else {
                    // No errorItemGenerator set, return empty items
                    return ListSections.readyToDisplay([])
                }
            } else {
                if let noResultsSection = noResultsSection {
                    return ListSections.readyToDisplay([noResultsSection()])
                } else {
                    // No noResultsItemGenerator set, return empty items
                    return ListSections.readyToDisplay([])
                }
            }
        }
        
        func numberOfItems(_ sections: [SectionWithItems<Item, Section>]) -> Int {
            return sections.map({ $0.items.count }).reduce(0, +)
        }
        
        switch provisioningState {
        case .notReady:
            return ListSections<Item, Section>.notReady
        case .loading:
            if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                // Loading and there are cached items, return them
                return ListSections.readyToDisplay(sections)
            } else if let error = self.error, let errorSection = errorSection {
                // Loading, error, and there are empty cached items, return error item
                return ListSections.readyToDisplay([errorSection(error)])
            } else if let _ = value {
                // Loading and there are empty cached items, return error or noResults item
                return noResultsOrErrorSection()
            } else {
                // Loading and there is no cached value, return loading item
                if let loadingSection = loadingSection {
                    return ListSections.readyToDisplay([loadingSection()])
                } else {
                    // No loadingCellGenerator set, return empty items
                    return ListSections.readyToDisplay([])
                }
            }
        case .result:
            if let value = self.value {
                if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                    // Success, return items
                    return ListSections.readyToDisplay(sections)
                } else {
                    // Success without items, return error or noResults item
                    return noResultsOrErrorSection()
                }
            } else {
                // Error and no cached items, return error item (or noResults item as fallback)
                return noResultsOrErrorSection()
            }
        }
    }
    
    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    public func singleSectionListItems<Item: ListItem>(valueToItems: @escaping (Value) -> [Item]?,
                                                       loadingItem: (() -> Item)? = nil,
                                                       errorItem: ((E) -> Item)? = nil,
                                                       noResultsItem: (() -> Item)? = nil) -> SingleSectionListItems<Item> {
        
        func boxedValueToItems(_ box: EquatableBox<Value>?) -> [Item]? {
            return (box?.value).flatMap({ valueToItems($0) })
        }
        
        func noResultsOrErrorItem() -> SingleSectionListItems<Item> {
            if let error = self.error {
                if let errorItem = errorItem {
                    return SingleSectionListItems<Item>.readyToDisplay([errorItem(error)])
                } else if let noResultsItem = noResultsItem {
                    return SingleSectionListItems<Item>.readyToDisplay([noResultsItem()])
                } else {
                    // No errorItemGenerator set, return empty items
                    return SingleSectionListItems<Item>.readyToDisplay([])
                }
            } else {
                if let noResultsItem = noResultsItem {
                    return SingleSectionListItems<Item>.readyToDisplay([noResultsItem()])
                } else {
                    // No noResultsItemGenerator set, return empty items
                    return SingleSectionListItems<Item>.readyToDisplay([])
                }
            }
        }
        
        switch provisioningState {
        case .notReady:
            return SingleSectionListItems<Item>.notReady
        case .loading:
            if let items = boxedValueToItems(value), items.isEmpty == false {
                // Loading and there are cached items, return them
                return SingleSectionListItems<Item>.readyToDisplay(items)
            } else if let error = self.error, let errorItem = errorItem {
                // Loading, error, and there are empty cached items, return error item
                return SingleSectionListItems<Item>.readyToDisplay([errorItem(error)])
            } else if let _ = value {
                // Loading and there are empty cached items, return error or noResults item
                return noResultsOrErrorItem()
            } else {
                // Loading and there is no cached value, return loading item
                if let loadingItem = loadingItem {
                    return SingleSectionListItems<Item>.readyToDisplay([loadingItem()])
                } else {
                    // No loadingCellGenerator set, return empty items
                    return SingleSectionListItems<Item>.readyToDisplay([])
                }
            }
        case .result:
            if let value = self.value {
                if let cells = boxedValueToItems(value), cells.isEmpty == false {
                    // Success, return items
                    return SingleSectionListItems<Item>.readyToDisplay(cells)
                } else {
                    // Success without items, return error or noResults item
                    return noResultsOrErrorItem()
                }
            } else {
                // Error and no cached items, return error item (or noResults item as fallback)
                return noResultsOrErrorItem()
            }
        }
    }
}

